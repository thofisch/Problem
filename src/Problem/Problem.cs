using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Net;
using System.Reflection;
using Newtonsoft.Json;

namespace Trifork
{
    /// <summary>
    /// See <a href="https://tools.ietf.org/html/rfc7807">RFC 7807: Problem Details for HTTP APIs</a>
    /// </summary>
    public class Problem
    {
        private static readonly ISet<string> ReservedProperties = new HashSet<string>(new[] {"type", "title", "status", "detail", "instance", "cause"});

        public static Problem From(StatusType status)
        {
            return new Problem()
                .WithTitle(status.ReasonPhrase)
                .WithStatus(status);
        }

        public static Problem From(StatusType status, string detail)
        {
            return From(status).WithDetail(detail);
        }

        public static Problem From(StatusType status, Uri instance)
        {
            return From(status).WithInstance(instance);
        }

        public static Problem From(StatusType status, string detail, Uri instance)
        {
            return From(status).WithDetail(detail).WithInstance(instance);
        }

        [JsonConstructor]
        private Problem()
        {
        }

        /// <summary>
        /// A URI reference that identifies the problem type.This specification encourages that,
        /// when dereferenced, It provide human-readable documentation for the problem type
        /// (e.g., using HTML [W3C.REC-html5-20141028]).  When this member is not present, its
        /// value is assumed to be "about:blank". Consumers MUST use the "type" string as the
        /// primary identifier for the problem type. When "about:blank" is used, the title SHOULD
        /// be the same as the recommended HTTP status phrase for that code(e.g.,  "Not Found" for
        /// 404, and so on), although it MAY be localized to suit client preferences (expressed
        /// with the Accept-Language request header).
        /// </summary>
        public Uri Type { get; set; }

        /// <summary>
        /// A short, human-readable summary of the problem type.It SHOULD NOT change from
        /// occurrence to occurrence of the problem, except for purposes of localization(e.g.,
        /// using proactive content negotiation; see[RFC7231], Section 3.4)  the "title" string
        /// is advisory and included only for users who are not aware of the semantics of the URI
        /// and do not have the ability to discover them (e.g., offline log analysis). Consumers
        /// SHOULD NOT automatically dereference the type URI.
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// The HTTP status code ([RFC7231], Section 6) generated by the origin server for this
        /// occurrence  of the problem. The "status" member, if present, is only advisory; it
        /// conveys the HTTP status code used for the convenience of the consumer.  Generators
        /// MUST use the same status code in the actual HTTP response, to assure that generic HTTP
        /// software that does not understand this format still behaves correctly. See Section 5
        /// for further caveats regarding its use.
        /// </summary>
        [JsonConverter(typeof(StatusTypeConverter))]
        public StatusType Status { get; set; }

        /// <summary>
        /// A human-readable explanation specific to this occurrence of the problem. The "detail"
        /// member, if present, ought to focus on helping the client correct the problem, rather
        /// than giving debugging information. Consumers SHOULD NOT parse the "detail" member for
        /// information; extensions are more suitable and less error-prone ways to obtain such
        /// information.
        /// </summary>
        public string Detail { get; set; }

        /// <summary>
        /// A URI reference that identifies the specific occurrence of the problem.  It may or may
        /// not yield further information if dereferenced.
        /// </summary>
        public Uri Instance { get; set; }

        public Problem Cause { get; set; }

        /// <summary>
        /// Optional, additional attributes of the problem.  Implementations can choose to ignore
        /// this in favor of concrete, typed fields.
        /// </summary>
        [JsonExtensionData]
        public IDictionary<string, object> Parameters { get; } = new Dictionary<string, object>();

        public Problem WithType(Uri type)
        {
            Type = type;
            return this;
        }

        public Problem WithTitle(string title)
        {
            Title = title;
            return this;
        }

        public Problem WithStatus(StatusType status)
        {
            Status = status;
            return this;
        }

        public Problem WithDetail(string detail)
        {
            Detail = detail;
            return this;
        }

        public Problem WithInstance(Uri instance)
        {
            Instance = instance;
            return this;
        }

        public Problem WithCause(Problem cause)
        {
            Cause = cause;
            return this;
        }

        public Problem With(string key, object value)
        {
            if (ReservedProperties.Contains(key))
            {
                throw new ArgumentException($"Property {key} is reserved", nameof(key));
            }
            Parameters.Add(key, value);
            return this;
        }

        public override string ToString()
        {
            var parts = new[]
            {
                Status?.StatusCode.ToString(),
                Title,
                Detail,
                Instance == null ? null : "instance=" + Instance,
                Parameters.Count == 0
                    ? null
                    : "parameters={" + string.Join(",", Parameters.Select(param => $"{param.Key}={param.Value}")) + "}"
            }.Where(x => x != null);

            return $"{GetType().Name}{{{string.Join(", ", parts)}}}";
        }
    }

    [Serializable]
    [DebuggerDisplay("<{StatusCode} ({ReasonPhrase,nq})>")]
    public class StatusType : IComparable<StatusType>, IEquatable<StatusType>
    {
        public static readonly StatusType Continue = new StatusType(HttpStatusCode.Continue, "Continue");
        public static readonly StatusType SwitchingProtocols = new StatusType(HttpStatusCode.SwitchingProtocols, "Switching Protocols");
        public static readonly StatusType Processing = new StatusType(102, "Processing");
        public static readonly StatusType Checkpoint = new StatusType(103, "Checkpoint");

        public static readonly StatusType Ok = new StatusType(HttpStatusCode.OK, "OK");
        public static readonly StatusType Created = new StatusType(HttpStatusCode.Created, "Created");
        public static readonly StatusType Accepted = new StatusType(HttpStatusCode.Accepted, "Accepted");
        public static readonly StatusType NonAuthoritativeInformation = new StatusType(HttpStatusCode.NonAuthoritativeInformation, "Non-Authoritative Information");
        public static readonly StatusType NoContent = new StatusType(HttpStatusCode.NoContent, "No Content");
        public static readonly StatusType ResetContent = new StatusType(HttpStatusCode.ResetContent, "Reset Content");
        public static readonly StatusType PartialContent = new StatusType(HttpStatusCode.PartialContent, "Partial Content");
        public static readonly StatusType MultiStatus = new StatusType(207, "Multi-Status");
        public static readonly StatusType AlreadyReported = new StatusType(208, "Already Reported");
        public static readonly StatusType InstanceManipulationUsed = new StatusType(226, "IM Used");

        public static readonly StatusType MultipleChoices = new StatusType(HttpStatusCode.MultipleChoices, "Multiple Choices");
        public static readonly StatusType MovedPermanently = new StatusType(HttpStatusCode.MovedPermanently, "Moved Permanently");
        public static readonly StatusType Found = new StatusType(HttpStatusCode.Found, "Found");
        public static readonly StatusType SeeOther = new StatusType(HttpStatusCode.SeeOther, "See Other");
        public static readonly StatusType NotModified = new StatusType(HttpStatusCode.NotModified, "Not Modified");
        public static readonly StatusType UseProxy = new StatusType(HttpStatusCode.UseProxy, "Use Proxy");
        public static readonly StatusType TemporaryRedirect = new StatusType(HttpStatusCode.TemporaryRedirect, "Temporary Redirect");
        public static readonly StatusType PermanentRedirect = new StatusType(308, "Permanent Redirect");

        public static readonly StatusType BadRequest = new StatusType(HttpStatusCode.BadRequest, "Bad Request");
        public static readonly StatusType Unauthorized = new StatusType(HttpStatusCode.Unauthorized, "Unauthorized");
        public static readonly StatusType PaymentRequired = new StatusType(HttpStatusCode.PaymentRequired, "Payment Required");
        public static readonly StatusType Forbidden = new StatusType(HttpStatusCode.Forbidden, "Forbidden");
        public static readonly StatusType NotFound = new StatusType(HttpStatusCode.NotFound, "Not Found");
        public static readonly StatusType MethodNotAllowed = new StatusType(HttpStatusCode.MethodNotAllowed, "Method Not Allowed");
        public static readonly StatusType NotAcceptable = new StatusType(HttpStatusCode.NotAcceptable, "Not Acceptable");
        public static readonly StatusType ProxyAuthenticationRequired = new StatusType(HttpStatusCode.ProxyAuthenticationRequired, "Proxy Authentication Required");
        public static readonly StatusType RequestTimeout = new StatusType(HttpStatusCode.RequestTimeout, "Request Timeout");
        public static readonly StatusType Conflict = new StatusType(HttpStatusCode.Conflict, "Conflict");
        public static readonly StatusType Gone = new StatusType(HttpStatusCode.Gone, "Gone");
        public static readonly StatusType LengthRequired = new StatusType(HttpStatusCode.LengthRequired, "Length Required");
        public static readonly StatusType PreconditionFailed = new StatusType(HttpStatusCode.PreconditionFailed, "Precondition Failed");
        public static readonly StatusType RequestEntityTooLarge = new StatusType(HttpStatusCode.RequestEntityTooLarge, "Request Entity Too Large");
        public static readonly StatusType RequestUriTooLong = new StatusType(HttpStatusCode.RequestUriTooLong, "Request-Uri Too Long");
        public static readonly StatusType UnsupportedMediaType = new StatusType(HttpStatusCode.UnsupportedMediaType, "Unsupported Media Type");
        public static readonly StatusType RequestedRangeNotSatisfiable = new StatusType(HttpStatusCode.RequestedRangeNotSatisfiable, "Requested Range Not Satisfiable");
        public static readonly StatusType ExpectationFailed = new StatusType(HttpStatusCode.ExpectationFailed, "Expectation Failed");
        public static readonly StatusType ImATeapot = new StatusType(418, "I'm a teapot");
        public static readonly StatusType MisdirectedRequest = new StatusType(421, "Misdirected Request");
        public static readonly StatusType UnprocessableEntity = new StatusType(422, "Unprocessable Entity");
        public static readonly StatusType Locked = new StatusType(423, "Locked");
        public static readonly StatusType FailedDependency = new StatusType(424, "Failed Dependency");
        public static readonly StatusType UpgradeRequired = new StatusType(HttpStatusCode.UpgradeRequired, "Upgrade Required");
        public static readonly StatusType PreconditionRequired = new StatusType(428, "Precondition Required");
        public static readonly StatusType TooManyRequests = new StatusType(429, "Too Many Requests");
        public static readonly StatusType RequestHeaderFieldsTooLarge = new StatusType(431, "Request Header Fields Too Large");
        public static readonly StatusType ConnectionClosedWithoutResponse = new StatusType(444, "Connection Closed Without Response");
        public static readonly StatusType UnavailableForLegalReasons = new StatusType(451, "Unavailable For Legal Reasons");
        public static readonly StatusType ClientClosedRequest = new StatusType(499, "Client Closed Request");

        public static readonly StatusType InternalServerError = new StatusType(HttpStatusCode.InternalServerError, "Internal Server Error");
        public static readonly StatusType NotImplemented = new StatusType(HttpStatusCode.NotImplemented, "Not Implemented");
        public static readonly StatusType BadGateway = new StatusType(HttpStatusCode.BadGateway, "Bad Gateway");
        public static readonly StatusType ServiceUnavailable = new StatusType(HttpStatusCode.ServiceUnavailable, "Service Unavailable");
        public static readonly StatusType GatewayTimeout = new StatusType(HttpStatusCode.GatewayTimeout, "Gateway Timeout");
        public static readonly StatusType HttpVersionNotSupported = new StatusType(HttpStatusCode.HttpVersionNotSupported, "Http Version Not Supported");
        public static readonly StatusType VariantAlsoNegotiates = new StatusType(506, "Variant Also Negotiates");
        public static readonly StatusType InsufficientStorage = new StatusType(507, "Insufficient Storage");
        public static readonly StatusType LoopDetected = new StatusType(508, "Loop Detected");
        public static readonly StatusType BandwidthLimitExceeded = new StatusType(509, "Bandwidth Limit Exceeded");
        public static readonly StatusType NotExtended = new StatusType(510, "Not Extended");
        public static readonly StatusType NetworkAuthenticationRequired = new StatusType(511, "Network Authentication Required");
        public static readonly StatusType NetworkConnectTimeoutError = new StatusType(599, "Network Connect Timeout Error");

        private static readonly Lazy<StatusType[]> Enumerations = new Lazy<StatusType[]>(GetEnumerations);

        private StatusType(int statusCode, string reasonPhrase)
        {
            StatusCode = statusCode;
            ReasonPhrase = reasonPhrase;
        }

        private StatusType(HttpStatusCode httpStatusCode, string reasonPhrase) : this((int) httpStatusCode, reasonPhrase)
        {
        }

        public int StatusCode { get; }
        public string ReasonPhrase { get; }

        public int CompareTo(StatusType other)
        {
            return StatusCode.CompareTo(other.StatusCode);
        }

        public sealed override string ToString()
        {
            return ReasonPhrase;
        }

        public static StatusType[] GetAll()
        {
            return Enumerations.Value;
        }

        private static StatusType[] GetEnumerations()
        {
            return typeof(StatusType)
                .GetFields(BindingFlags.Public | BindingFlags.Static | BindingFlags.DeclaredOnly)
                .Where(info => typeof(StatusType).IsAssignableFrom(info.FieldType))
                .Select(info => info.GetValue(null))
                .Cast<StatusType>()
                .ToArray();
        }

        public override bool Equals(object obj)
        {
            return Equals(obj as StatusType);
        }

        public bool Equals(StatusType other)
        {
            return other != null && StatusCode.Equals(other.StatusCode);
        }

        public override int GetHashCode()
        {
            return StatusCode.GetHashCode();
        }

        public static bool operator ==(StatusType left, StatusType right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(StatusType left, StatusType right)
        {
            return !Equals(left, right);
        }

        public static StatusType FromValue(int statusCode)
        {
            return Parse(statusCode, "statusCode", x => x.StatusCode == statusCode);
        }

        public static StatusType FromValue(HttpStatusCode httpStatusCode)
        {
            return Parse(httpStatusCode, "statusCode", x => x.StatusCode == (int) httpStatusCode);
        }

        private static StatusType Parse<T>(T value, string description, Func<StatusType, bool> predicate)
        {
            StatusType result;

            if (!TryParse(predicate, out result))
            {
                var message = $"'{value}' is not a valid {description} in {typeof(StatusType)}";
                throw new ArgumentException(message, nameof(value));
            }
            return result;
        }

        private static bool TryParse(Func<StatusType, bool> predicate, out StatusType result)
        {
            result = GetAll().FirstOrDefault(predicate);
            return result != null;
        }

        public static bool TryParse(int value, out StatusType result)
        {
            return TryParse(e => e.StatusCode == value, out result);
        }

        public static bool TryParse(HttpStatusCode httpStatusCode, out StatusType result)
        {
            return TryParse(e => e.StatusCode == (int) httpStatusCode, out result);
        }
    }

    public class StatusTypeConverter : JsonConverter
    {
        private static readonly ConcurrentDictionary<Type, TypeConverter> TypeConverters = new ConcurrentDictionary<Type, TypeConverter>();

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            var statusType = (StatusType) value;

            writer.WriteValue(statusType.StatusCode);
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.Value == null)
            {
                throw new InvalidOperationException("Cannot accept <null> as a StatusType value");
            }

            var typeConverter = TypeConverters.GetOrAdd(reader.ValueType, TypeDescriptor.GetConverter);

            if (!typeConverter.CanConvertTo(typeof(int)))
            {
                throw new InvalidOperationException($"Cannot accept StatusType of type '{reader.ValueType}' with value '{reader.Value}'.");
            }

            return StatusType.FromValue((int) typeConverter.ConvertTo(reader.Value, typeof(int)));
        }

        public override bool CanConvert(Type objectType)
        {
            return typeof(StatusType).IsAssignableFrom(objectType);
        }
    }
}